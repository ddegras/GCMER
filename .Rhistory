# data cora
# for blocking
rm(list = ls())
library(cora)
library(stringdist)
data(cora)
names(cora)
system.time(d.cora <- d.matrix(dat = cora, features = names(cora)[2:5], size = 0.5))
source("R/distance.calc.R")
system.time(d.cora <- d.matrix(dat = cora, features = names(cora)[2:5], size = 0.5))
thres <- 0.25
cora[which(d.cora[12,] <= thres), ]
install.packages("entity")
# data cora
# for blocking
rm(list = ls())
library(cora)
library(stringdist)
data(cora)
head(cora_gold)
head(cora_gold_update)
str(cora_gold)
# This data set includes the matched record pairs based on ID from the CORA
# data set. This data set can be used to evaluate the performance of record
# linkage methods performed on the CORA data set.
head(cora_gold, 30)
# package 'cd'
install.packages("cd")
library(cd)
str(cd)
cd_gold
dim(cd)
names(cd)
install.packages("representr")
library(representr)
library(igraph)
library(optrees)
library(rlemon)
install.packages(rlemon)
install.packages("rlemon")
library(rlemon)
## Figure 5 from Gomory and Hu (1961)
edges <- cbind(	e1 = c(1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5),
e2 = c(2, 6, 3, 5, 6, 4, 5, 6, 5, 6, 6),
w = c(10,  8,  4,  2,  3,  5,  4,  2,  7,  2,  3)
)
edges
## Min Cut Tree with package 'optrees' (incorrect)
tree1 <- getMinimumCutTree(1:6, edges)
## Min Cut Tree with package 'rlemon' (correct)
tree2 <- AllPairsMinCut(arcSources = edges[,1], arcTargets = edges[,2],
arcWeights = edges[,3], numNodes = 6)
## Plot original graph and correct min cut tree
g <- graph_from_edgelist(edges[,1:2], directed = FALSE)
treeasgraph <- graph_from_edgelist(
cbind(1:5, tree2$predecessors[1:5]), directed = FALSE)
dev.new()
par(mfrow = c(1,2))
plot(g, vertex.label = 1:6, edge.label = edges[,3])
title("Original Graph")
plot(treeasgraph, vertex.label = 1:6, edge.label = tree2$weights[1:5])
title("Minimum Cut Tree (Correct)")
par(mfrow = c(1,2))
plot(g, vertex.label = 1:6, edge.label = edges[,3])
title("Original Graph")
plot(treeasgraph, vertex.label = 1:6, edge.label = tree2$weights[1:5])
title("Minimum Cut Tree (Correct)")
edges[,1:2]
str(tree2)
tree2
make.adj.mat <- function(n, weight = c("none", "random")){
adj.mat <- matrix(0, n, n) # create an adjacency matrix
idx <- sample(1:(n^2), 2 * n) # randomly create edges
if(weight == "random"){
weight <- runif(2*n)
adj.mat[idx] <- weight
}else{
adj.mat[idx] <- 1
}
diag(adj.mat) <- 0
adj.mat <- adj.mat + t(adj.mat) # make sure it's symmetric
adj.mat[adj.mat > 1] <- 1
return(adj.mat)
}
g <- make.adj.mat(8, "none")
g
sapply(g, function(i) g[i, ] == 1)
sapply(g, function(obj) obj == 1)
apply(g, 1, g == 1)
isConnected <- function(x){
ifelse(x==1, TRUE, FALSE)
}
apply(g, 1, isConnected)
which(apply(g, 1, isConnected))
which(apply(g, 1, isConnected), arr.ind = TRUE)
neighborhood_list <- convert_to_neighborhood_list(g)
convert_to_neighborhood_list <- function(adj_matrix) {
n <- nrow(adj_matrix)
neighborhood_list <- vector("list", n)
for (i in 1:n) {
neighbors <- which(adj_matrix[i, ] == 1)
neighborhood_list[[i]] <- neighbors
}
return(neighborhood_list)
}
neighborhood_list <- convert_to_neighborhood_list(g)
print(neighborhood_list)
g
lapply(g, function(i) which(g[i,] == 1))
lapply(g, 1, which(g[i,] == 1))
apply(g, 1, which(g[i,] == 1))
sapply(g, function(i) which(g[i,] == 1))
mapply(g, function(i) which(g[i,] == 1))
g
apply(g, 1, function(i) which(g[i,] == 1))
apply(g, 2, function(i) which(g[i,] == 1))
apply(g, function(i) which(g[i,] == 1))
?apply
apply(g, 1, function(i) which(i == 1))
which(g == 1, arr.ind = TRUE)
source("helpers.R")
source("R/helpers.Rhelpers.R")
source("R//helpers.Rhelpers.R")
setwd("D:/Github/graph.coloring.dedup/")
source("helpers.Rhelpers.R")
source("helpers.R")
g <- make.adj.mat(8, "none")
g
apply(g, 1, function(i) which(i == 1))
convert_to_neighborhood_list <- function(adj_matrix) {
n <- nrow(adj_matrix)
neighborhood_list <- vector("list", n)
for (i in 1:n) {
neighbors <- which(adj_matrix[i, ] == 1)
neighborhood_list[[i]] <- neighbors
}
return(neighborhood_list)
}
convert_to_neighborhood_list(g)
convert_to_neighborhood_list <- function(adj_matrix) {
neighborhood_list <- apply(g, 1, function(i) which(i == 1))
return(neighborhood_list)
}
convert_to_neighborhood_list(g)
system.time(
g <- make.adj.mat(8, "none"),
test <- convert_to_neighborhood_list(g)
)
g <- make.adj.mat(8, "none")
system.time(
test <- convert_to_neighborhood_list(g)
)
g <- make.adj.mat(80, "none")
system.time(
test <- convert_to_neighborhood_list(g)
)
g <- make.adj.mat(800, "none")
system.time(
test <- convert_to_neighborhood_list(g)
)
convert_to_neighborhood_list <- function(adj_matrix) {
n <- nrow(adj_matrix)
neighborhood_list <- vector("list", n)
for (i in 1:n) {
neighbors <- which(adj_matrix[i, ] == 1)
neighborhood_list[[i]] <- neighbors
}
return(neighborhood_list)
}
system.time(
test <- convert_to_neighborhood_list(g)
)
g <- make.adj.mat(8000, "none")
system.time(
test <- convert_to_neighborhood_list(g)
)
convert_to_neighborhood_list <- function(adj_matrix) {
neighborhood_list <- apply(g, 1, function(i) which(i == 1))
return(neighborhood_list)
}
system.time(
test <- convert_to_neighborhood_list(g)
)
length(test)
str(test[1:5])
test[1:2]
dim(g)
g[1:10,1:10]
?make.adj.mat
formula(make.adj.mat())
formula(make.adj.mat
)
convert_to_three_column_table <- function(adj_matrix) {
n <- nrow(adj_matrix)
edges <- which(adj_matrix != 0, arr.ind = TRUE)
three_column_table <- data.frame(
From = edges[, 1],
To = edges[, 2],
Weight = adj_matrix[edges]
)
return(three_column_table)
}
# Convert the adjacency matrix to a three-column table
three_column_table <- convert_to_three_column_table(g)
print(three_column_table)
g <- make.adj.mat(10, "none")
g <- make.adj.mat(10, "none")
system.time(
#test <- convert_to_neighborhood_list(g)
test <- convert_to_three_column_table(g)
)
g <- make.adj.mat(1000, "none")
system.time(
#test <- convert_to_neighborhood_list(g)
test <- convert_to_three_column_table(g)
)
test[1:20,]
g <- make.adj.mat(10, "none")
system.time(
#test <- convert_to_neighborhood_list(g)
test <- convert_to_three_column_table(g)
)
test[1:20,]
g <- make.adj.mat(8, "random")
g
system.time(
#test <- convert_to_neighborhood_list(g)
test <- convert_to_three_column_table(g)
)
test[1:20,]
#
edge_table_to_adj_matrix <- function(edge_table, direct = TRUE) {
# Find the maximum vertex label to determine the size of the matrix
max_vertex <- max(edge_table$From, edge_table$To)
# Initialize an adjacency matrix of appropriate size with all zeros
adj_matrix <- matrix(0, nrow = max_vertex, ncol = max_vertex)
# Fill in the adjacency matrix
for (i in 1:nrow(edge_table)) {
from <- edge_table$From[i]
to <- edge_table$To[i]
weight <- edge_table$Weight[i]
adj_matrix[from, to] <- weight
if(!direct){
adj_matrix[to, from] <- weight
}
}
return(adj_matrix)
}
# Example Usage:
# Let's create a sample edge table
edge_table <- data.frame(
From = c(1, 2, 2, 3, 4),
To = c(2, 1, 3, 4, 3),
Weight = c(1, 1, 1, 1, 1)  # Assuming a simple unweighted graph
)
# Convert the edge table to an adjacency matrix
adj_matrix <- convert_to_adjacency_matrix(edge_table, TRUE)
# Convert the edge table to an adjacency matrix
adj_matrix <- edge_table_to_adj_matrix(edge_table, TRUE)
print(adj_matrix)
# Convert the edge table to an adjacency matrix
adj_matrix <- edge_table_to_adj_matrix(edge_table, FALSE)
print(adj_matrix)
g
system.time(
#test <- convert_to_neighborhood_list(g)
#test <- convert_to_three_column_table(g)
test <- edge_table_to_adj_matrix(edge_table, FALSE)
)
test
neighborhood_list_to_3column_table <- function(neighborhood_list, is_directed = TRUE, default_weight = 1) {
# Initialize vectors to store the 'From', 'To', and 'Weight' data
from <- numeric()
to <- numeric()
weight <- numeric()
# Iterate over the neighborhood list to populate the vectors
for (node in seq_along(neighborhood_list)) {
nbrs <- neighborhood_list[[node]]
n_edges <- length(nbrs)
from <- c(from, rep(node, n_edges))
to <- c(to, nbrs)
weight <- c(weight, rep(default_weight, n_edges))
}
# Create a data frame from the vectors
edge_table <- data.frame(From = from, To = to, Weight = weight)
return(edge_table)
}
neighborhood_list <- list(
c(2),       # Neighbors of node 1
c(1, 3, 4), # Neighbors of node 2
c(4),       # Neighbors of node 3
c(3)        # Neighbors of node 4
)
system.time(
#test <- convert_to_neighborhood_list(adj_matrix)
#test <- convert_to_three_column_table(adj_matrix)
#test <- edge_table_to_adj_matrix(edge_table, FALSE)
test <- neighborhood_list_to_3column_table
)
test
system.time(
#test <- convert_to_neighborhood_list(adj_matrix)
#test <- convert_to_three_column_table(adj_matrix)
#test <- edge_table_to_adj_matrix(edge_table, FALSE)
test <- neighborhood_list_to_3column_table(neighborhood_list)
)
test
seq_along(neighborhood_list)
neighborhood_list
rm(list = ls())
library(cora)
library(stringdist)
data(cora)
system.time(d.cora <- d.matrix(dat = cora, features = names(cora)[2:5], size = 0.5))
source("R/distance.calc.R")
system.time(d.cora <- d.matrix(dat = cora, features = names(cora)[2:5], size = 0.5))
thres <- 0.25
cora[which(d.cora[12,] <= thres), ]
blocks <- apply(d.cora <= thres, 2, which)
blen <- sapply(blocks, length)
blocks <- blocks[blen > 0]
nblocks <- length(blocks)
blocks[1:10]
unique(blocks)
blocks <- unique(blocks)
blocks[1:10]
blk <- blocks[sapply(blocks, length) > 1]
length(blk)
length(blocks)
blocks <- apply(d.cora <= thres, 2, which)
blen <- sapply(blocks, length)
blocks <- blocks[blen > 0]
blocks <- blocks[blen > 1]
blocks <- unique(blocks)
nblocks <- length(blocks)
nblocks
blocks[1:5]
str(d.cora)
dtitle
require("textreuse") # text reuse/document similarity
require("tokenizers")# shingles
str(d.cora)
d.cora[1:10, 1:10]
b <- 1
idx <- blocks[b]
idx
d.cora[idx, idx]
class(d.cora)
dim(d.cora)
idx <- unlist(blocks[b])
d.cora[idx, idx]
d.mat <- d.cora[idx, idx]
sim.mat <- d.cora[idx, idx]
thres <- 0.25
sim.mat > thres
comp.mat <- !(sim.mat > thres)
comp.mat
comp.mat <- as.integer(!(sim.mat > thres))
comp.mat
apply(comp.mat == TRUE, 2, which, simplify = FALSE)
comp.mat == TRUE
comp.mat
sim.mat <- d.cora[idx, idx]
comp.mat <- !(sim.mat > thres)
comp.mat
apply(comp.mat == TRUE, 2, which, simplify = FALSE)
adj_matrix_to_neighborhood_list(comp.mat)
source("R/graph.representation.R")
adj_matrix_to_neighborhood_list(comp.mat)
adj.list <- adj_matrix_to_neighborhood_list(comp.mat)
graph.coloring(adj.list)
source("graph.coloring.R")
graph.coloring(adj.list)
is.matrix(adj.list)
adjmat2list <- function(mat)
{
stopifnot(is.matrix(mat))
stopifnot(identical(rownames(mat), colnames(mat)))
stopifnot(is.numeric(mat[1]) || is.logical(mat[1]))
stopifnot(nrow(mat) == ncol(mat))
stopifnot(all(mat == t(mat)))
if (is.numeric(mat[1])) {
stopifnot(all(mat %in% c(0, 1)))
stopifnot(all(diag(mat) == 0))
out <- apply(mat == 1, 2, which)
} else {
stopifnot(all(!diag(mat)))
out <- apply(mat, 2, which)
}
names(out) <- rownames(mat)
out
}
graph.coloring(adj.list)
#code.dir <- "~/Documents/GitHub/Data-Analytics-Lab-Prof.Degras/EntityResolution/graph.coloring.dedup"#DD
code.dir <- "D:\\Github\\graph.coloring.dedup"#XM
source(file.path(code.dir, "helpers.R"))
source(file.path(code.dir, "graph.coloring.R"))
cora[which(d.cora[12,] <= thres), ]
library(cora)
data(cora)
datafolder <- "D:/Github/Data-Analytics-Lab-Prof.Degras/EntityResolution/DataResource/"
data <- read.csv(file.path(datafolder, "affiliationstrings_ids.csv"))
library(stringdist)
x <- tolower(data[,2])
x
first <- strsplit(x, ",", fixed = TRUE)
first <- sapply(first, "[[", 1)
first
## Calculate distance matrix
d <- stringdistmatrix(x)
dmat <- as.matrix(d)
## Remove commas at the beginning of string
gsub("^,", "", ",abc,")
dmat[1:5,1:5]
x <- gsub(pattern = "⁠,", replacement = "", x = x, fixed = TRUE)
head(x)
gsub("[^[:alnum:]_]⁠", "", aff[,2])
x <- c("abc,", ",n,")
gsub(",", "", x)
